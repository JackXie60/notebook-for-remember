# 原型和原型链

- 所有对象都是通过`new 函数`创建的

```
function test(){
    return {}
}
console.log(new test())
```

![](./images/IMG20210801103116.jpg)
打印出来的是一个 object 对象，构造函数是 Object,因为如果**函数里面返回的是一个对象的话，new 这个函数得到的是它的返回结果**

```
function test(){

}
console.log(new test())
```

打印出来一个 test 对象

- 所有的函数都是对象
  - 函数中可以有属性
- 所有对象都是引用类型

## 原型 prototype

所有**函数**都有一个属性:prototype,称为函数原型
默认情况下 prototype 是一个 object 对象
prototype = {

}
默认情况下，prototype 中有一个属性，constructor，默认指向构造函数本身
test.prototype.constructor = test

## 隐式原型

所有的**对象**都有一个属性**proto**,称为隐式原型
![](./images/IMG20210801104028.jpg)
**隐式原型指向创建该对象的函数的原型**

```
function test(){

}
const obj = new test()
```

> obj.**proto** === test.prototype//true

当访问一个对象的成员时

1. 看该对象自身是否拥有该成员，如果有直接使用
2. 看对象的隐式原型中是否有该成员，有就直接使用
3. 一直查找下去，知道在隐式原型中找到需要的成员时

猴子补丁:在函数原型中加入成员，以增强其对象的功能，猴子补丁会污染原型链，使用需要谨慎

## 原型链

通过隐式原型链条来访问成员
特殊点:

1. Function 的**proto**指向自身的 prototype
2. Object 的 prototype 的隐式原型等于 null
   ![](./images/IMG20210801111236.jpg)

## 面试题

```
var F = function(){}
Object.prototype.a = function(){}
Function.prototype.b = function(){}
var f = new F();
console.log(f.a,f.b,F.a,F.b)
//fn,undefined,fn,fn
```

```
function User(){}
User.prototype.sayHello = function(){}

const u1 = new User();
const u2 = new User();

console.log(u1.sayHello = u2.sayHello)//true,因为u.__proto__ === User.prototype
console.log(User.prototype.constructor)//User,User.prototype.constructor === User
console.log(User.prototype===Function.prototype)//false,User.__proto__===Function.prototype
console.log(User.__proto__===Function.prototype)//true
console.log(User.__proto__===Funtion.__proto__)//true，因为Function比较特殊，Function.prototype===Function.__proto__
console.log(u1.__proto__===u2.__proto__)//true,都等于User.prototype
console.log(u1.__proto__===User.__proto)//fale,u1.__proto__===User.prototype
console.log(Function.__proto__===Object.__proto__)//true
console.log(Funtion.prototype.__proto__===Object.prototype.__proto__)//false
cosnole.log(Function.prototype.__proto__===Object.prototype)//true
```

## 原型链的应用

**Object.getPrototypeOf(对象)**
获取对象的隐式原型
**Object.prototype.isPrototypeOf(对象)**
判断当前对象(this)是否在指定对象的原型链上
**对象 instanceof 函数**
判断函数的原型是否在对象的原型链上
**Object.create(对象)**
创建一个新对象，其隐式原型指向指定对象
**Object.prototype.hasOwnProperty(属性名)**
判断一个对象**自身**(不包括原型链)是否拥有某个属性

**类数组转换为真数组**
Array.prototype.slice.call(类数组)
**实现继承**
自定义函数继承自 Object，默认情况下，所有构造函数的父类都是 Object

```
function inherit(son,father){
            son.prototype = Object.create(father.prototype);
            son.prototype.constructor = son;
            son.prototype.uber = father.prototype;
        }
```
